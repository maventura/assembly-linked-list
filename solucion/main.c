#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "lista_colgante.h"


boolean funciontrue(nodo_t* n){ return True;}
// valor_elemento funcionsuma(valor_elemento a, valor_elemento b){
 //	a = a+b;
 //	return a;}
/*
void lista_colapsar_c(lista_colgante_t *self,nodo_bool_method test_method, nodo_value_method join_method){


nodo_t *actual = self->primero;
nodo_t *abajo = actual.hijo;

if(self->primero == NULL){return;}
actual = self.primero;
abajo = actual. hijo;

	while(actual /= NULL){

	if(test_method(actual) && actual.hijo/=NULL){
		while (abajo /= NULL){


			actual.valor = join_method(actual.valor, abajo.valor);
			abajo = abajo.hijo;

		}

		nodo_borrar_con_hijos(actual.hijo);
		actual = actual.siguiente;
	}else{
		actual = actual.siguiente;


	}




}


}

*/


int main() {


//PRUEBA CORTA PEDIDA POR LA CATEDRA





	lista_colgante_t *lista_nueva = lista_crear();
	lista_imprimir(lista_nueva,"archivo.txt");
	lista_borrar(lista_nueva);


	lista_colgante_t *lista_nueva2 = lista_crear();
	valor_elemento valor_nuevo = {.i=10};
	nodo_t *nodo_nuevo = nodo_crear(Integer, valor_nuevo);

	lista_concatenar(lista_nueva2, nodo_nuevo);

	lista_borrar(lista_nueva2); //habia que borrarla no?
	


	lista_colgante_t *lista_nueva3 = lista_crear();
	
	char *hola = malloc( sizeof(char) * (4 + 1));
	strcpy(hola, "hola");
	valor_elemento valor_hola = {.s=hola};

	char *chau = malloc( sizeof(char) * (4 + 1));
	strcpy(chau, "chau");
	valor_elemento valor_chau = {.s=chau};


	nodo_t *nodo_hola = nodo_crear(String, valor_hola);
	nodo_t *nodo_chau = nodo_crear(String, valor_chau);

	lista_concatenar(lista_nueva3, nodo_hola);
	lista_colgar_descendiente(lista_nueva3, 0, nodo_chau);

	lista_borrar(lista_nueva3);
/*

*/

//OTRAS PRUEBAS (IGNORAR, O COMENTAR SI HACE FALTA)


//PRUEBA DE CEROS EN DECIMAL
//	valor_elemento valor_ceros_en_decimal = {.i=-1037};
//	nodo_t *nodo_ceros = nodo_crear(Integer, valor_ceros_en_decimal);

//	tiene_ceros_en_decimal(nodo_ceros);




/*





	valor_elemento value = {.i=3};

//	char *s = "hola123";
 
	char *s = malloc( sizeof(char) * (7 + 1));
	strcpy(s, "hola123");
	valor_elemento svalue = {.s=s};

//	char *s2 = malloc( sizeof(char) * (7 + 1));
//	strcpy(s2, "chau456");
//	valor_elemento svalue2 = {.s=s2};


	lista_colgante_t *lista1 = lista_crear();
	lista_colgante_t *lista2 = lista_crear();


	nodo_t *nodo0 = nodo_crear(Integer, value);
	nodo_t *nodo1 = nodo_crear(Integer, value);
	nodo_t *nodo2 = nodo_crear(Integer, value);
//	nodo_t *nodo3 = nodo_crear(Integer, value);
//	nodo_t *nodo4 = nodo_crear(Integer, value);

//	nodo_t *nodoborrar0 = nodo_crear(Integer, value);
//	nodo_t *nodoborrar1 = nodo_crear(Integer, value);

	nodo_t *snodo = nodo_crear(String, svalue);

*/






/* TESTEO REVOLVER_PRIMERAS_5
valor_elemento rev =  revolver_primeras_5(svalue, svalue2);
printf("%s", rev.s);
*/


/*
//Nodos de prueba de nodo_concatenar.
	nodo_t *nodoc0 = nodo_crear(Integer, value);
	nodo_t *nodoc1 = nodo_crear(Integer, value);


	nodo_t **n = &(nodoc0->siguiente);
	nodo_concatenar(n,nodoc1);
	nodo_borrar(nodoc0);
//Los borro con nodo_borrar que borra hijos y siguientes.
*/



//	nodoborrar0->hijo = nodoborrar1;

/*
	lista_colgar_descendiente(lista1, 0, nodo0);
	lista_colgar_descendiente(lista1, 0, nodo1);
	lista_colgar_descendiente(lista1, 0, nodo2);
	//lista_colgar_descendiente(lista1, 0, nodo3);
	//lista_colgar_descendiente(lista1, 0, nodo4);
	lista_colgar_descendiente(lista2, 0, snodo);

*/

//	int num = 0;

//	num = tiene_numeros(snodo);

//	lista_imprimir(lista1,"archivo.txt");
//	nodo_borrar_con_hijos(nodoborrar0);
//	nodo_acceder(nodo1,0);


/*
	lista_imprimir(lista1,"archivo.txt");



	lista_colapsar(lista1, funciontrue, raiz_cuadrada_del_producto);



	lista_imprimir(lista1,"archivo.txt");

*/
/*
//	lista_filtrar(lista1, funciontrue);
	lista_borrar(lista1);
	lista_borrar(lista2);

*/

/* //testeo tiene_ceros_en_decimal
// Creo un nodo para el tiene_ceros_en_decimal
	valor_elemento value_ceros = {.i=808888};
	valor_elemento value_sin_ceros = {.i=1234056789};
	nodo_t *nodo_cero = nodo_crear(Integer, value_ceros);
	nodo_t *nodo_sin_ceros = nodo_crear(Integer, value_sin_ceros);

printf("\n ");
printf("\n nodo con ceros = ");

	printf("%i", tiene_ceros_en_decimal(nodo_cero));


printf("\n nodo sin ceros = ");


	printf("%i", tiene_ceros_en_decimal(nodo_sin_ceros));

printf("\n ");
*/


//testeo parte_decimal_mayor_que_un_medio


/*

	valor_elemento value_mayor = {.d=3.9999};
	valor_elemento value_menor = {.d=3.0};
	nodo_t *nodo_mayor = nodo_crear(Double, value_mayor);
	nodo_t *nodo_menor = nodo_crear(Double, value_menor);

	printf("\n ");

	int b = parte_decimal_mayor_que_un_medio(nodo_menor); //Para el booleano (int)

	printf("\n nodo menor = ");
	printf("%i", b);

	b = parte_decimal_mayor_que_un_medio(nodo_mayor);

	printf("\n nodo mayor = ");
	printf("%i", b);


	printf("\n ");

*/




	//testeo raiz_del_producto
/*	valor_elemento value1 = {.i=8};
	valor_elemento value2 = {.i=5};
	value1 = raiz_cuadrada_del_producto(value1, value2);
	printf ("\n la raíz es: %d \n", value1.i);
*/



/*
//testeo raiz_de_la_suma
	valor_elemento value1 = {.d=8.0};
	valor_elemento value2 = {.d=5.0};

	value1 = raiz_de_la_suma(value1, value2);
	printf ("\n la raíz es: %f \n", value1.d);
*/


	return 0;
}
